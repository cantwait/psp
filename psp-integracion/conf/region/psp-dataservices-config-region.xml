<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:cxf="http://www.mulesoft.org/schema/mule/cxf" xmlns:smtps="http://www.mulesoft.org/schema/mule/smtps"
	xmlns:pop3="http://www.mulesoft.org/schema/mule/pop3" xmlns:smtp="http://www.mulesoft.org/schema/mule/smtp"
	xmlns:pop3s="http://www.mulesoft.org/schema/mule/pop3s" xmlns:imap="http://www.mulesoft.org/schema/mule/imap"
	xmlns:imaps="http://www.mulesoft.org/schema/mule/imaps" xmlns:email="http://www.mulesoft.org/schema/mule/email"
	xmlns:file="http://www.mulesoft.org/schema/mule/file" xmlns:https="http://www.mulesoft.org/schema/mule/https"
	xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:jdbc="http://www.mulesoft.org/schema/mule/jdbc"
	xmlns:jms="http://www.mulesoft.org/schema/mule/jms" xmlns:json="http://www.mulesoft.org/schema/mule/json"
	xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting"
	xmlns:management="http://www.mulesoft.org/schema/mule/management"
	xmlns:ognl="http://www.mulesoft.org/schema/mule/ognl" xmlns:quartz="http://www.mulesoft.org/schema/mule/quartz"
	xmlns:tcp="http://www.mulesoft.org/schema/mule/tcp" xmlns:vm="http://www.mulesoft.org/schema/mule/vm"
	xmlns:mule-xml="http://www.mulesoft.org/schema/mule/xml" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:mongo="http://www.mulesoft.org/schema/mule/mongo" xmlns:jersey="http://www.mulesoft.org/schema/mule/jersey"
	xsi:schemaLocation="
          http://www.mulesoft.org/schema/mule/cxf http://www.mulesoft.org/schema/mule/cxf/current/mule-cxf.xsd
          http://www.mulesoft.org/schema/mule/smtps http://www.mulesoft.org/schema/mule/smtps/current/mule-smtps.xsd
          http://www.mulesoft.org/schema/mule/pop3 http://www.mulesoft.org/schema/mule/pop3/3.1/mule-pop3.xsd
          http://www.mulesoft.org/schema/mule/smtp http://www.mulesoft.org/schema/mule/smtp/3.3/mule-smtp.xsd
          http://www.mulesoft.org/schema/mule/pop3s http://www.mulesoft.org/schema/mule/pop3s/current/mule-pop3s.xsd
          http://www.mulesoft.org/schema/mule/imap http://www.mulesoft.org/schema/mule/imap/current/mule-imap.xsd
          http://www.mulesoft.org/schema/mule/imaps http://www.mulesoft.org/schema/mule/imaps/current/mule-imaps.xsd
          http://www.mulesoft.org/schema/mule/email http://www.mulesoft.org/schema/mule/email/3.2/mule-email.xsd
          http://www.mulesoft.org/schema/mule/file http://www.mulesoft.org/schema/mule/file/3.1/mule-file.xsd
          http://www.mulesoft.org/schema/mule/https http://www.mulesoft.org/schema/mule/https/current/mule-https.xsd
          http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
          http://www.mulesoft.org/schema/mule/jdbc http://www.mulesoft.org/schema/mule/jdbc/3.2/mule-jdbc.xsd
          http://www.mulesoft.org/schema/mule/jms http://www.mulesoft.org/schema/mule/jms/current/mule-jms.xsd
          http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
          http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/3.3/mule-scripting.xsd
          http://www.mulesoft.org/schema/mule/management http://www.mulesoft.org/schema/mule/management/3.2/mule-management.xsd
          http://www.mulesoft.org/schema/mule/ognl http://www.mulesoft.org/schema/mule/ognl/current/mule-ognl.xsd
          http://www.mulesoft.org/schema/mule/quartz http://www.mulesoft.org/schema/mule/quartz/current/mule-quartz.xsd
          http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
          http://www.mulesoft.org/schema/mule/tcp http://www.mulesoft.org/schema/mule/tcp/current/mule-tcp.xsd
          http://www.mulesoft.org/schema/mule/vm http://www.mulesoft.org/schema/mule/vm/3.1/mule-vm.xsd
          http://www.mulesoft.org/schema/mule/xml http://www.mulesoft.org/schema/mule/xml/current/mule-xml.xsd
          http://www.mulesoft.org/schema/mule/mongo http://www.mulesoft.org/schema/mule/mongo/2.0/mule-mongo.xsd
          http://www.mulesoft.org/schema/mule/jersey http://www.mulesoft.org/schema/mule/jersey/current/mule-jersey.xsd">

	<!-- Es importante incorporar en este fragmento de codigo el tipo de error, 
		si es de mongo, si es conexion, si es de validacion -->
	<!-- Guardar esto en una clase Groovy -->
	<!-- El mensaje de Error debe ser parametrizable con Mascaras para que pueda 
		sustituir por el Payload y la descripcion del Error -->

	<choice-exception-strategy name="Choice_Exception_Strategy">
		<catch-exception-strategy
			when="#[exception.causedBy(org.mule.api.routing.filter.FilterUnacceptedException)]"
			doc:name="Catch Exception Strategy">
			<scripting:transformer doc:name="Groovy">
				<scripting:script engine="Groovy"><![CDATA[
				    	import java.text.SimpleDateFormat;
		                import java.util.Date;
		                import java.text.DateFormat;
		                import java.util.Calendar;
		                import com.pdvsa.psp.model.xml.MongoLogger;
		                
						//org.mule.api.routing.filter.FilterUnacceptedException
						 DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		                String dateStr = dateFormat.format(Calendar.getInstance().getTime());
		                
		                Date currentTime = dateFormat.parse(dateStr);
		                
		                def log = new MongoLogger();
		                log.tipoEvento = MongoLogger.Evento.VALIDACION;	
						log.descripcion = "El XML Enviado no esta debidamente estructurado por favor Revise!";
						log.fecha = currentTime;
						log.causa = exception.cause;				
						
						return log;
						]]></scripting:script>
			</scripting:transformer>
			<component>
				<spring-object bean="mongoInsertLogComponent" />
			</component>
			<mule-xml:object-to-xml-transformer
				doc:name="Object to XML">
				<mule-xml:alias name="response"
					class="com.pdvsa.psp.model.xml.MongoLogger" />
			</mule-xml:object-to-xml-transformer>
		</catch-exception-strategy>
		<catch-exception-strategy
			when="#[exception.causedBy(java.net.ConnectException)]">
			<scripting:transformer doc:name="Groovy">
				<scripting:script engine="Groovy"><![CDATA[
				    	import java.text.SimpleDateFormat;
		                import java.util.Date;
		                import java.text.DateFormat;
		                import java.util.Calendar;
		                import com.pdvsa.psp.model.xml.MongoLogger;
		                
						//org.mule.api.routing.filter.FilterUnacceptedException
						 DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		                String dateStr = dateFormat.format(Calendar.getInstance().getTime());
		                
		                Date currentTime = dateFormat.parse(dateStr);
		                
		                def log = new MongoLogger();
		                log.tipoEvento = MongoLogger.Evento.CONEXION;	
						log.descripcion = "SE HA INTENTADO ENVIAR SIN EXITO LA CANTIDAD: "+ flowVars['originalPayload'] + " ITEMS AL DESTINO: " + exception.event.message.getOutboundProperty("MULE_ENDPOINT");
						log.fecha = currentTime;
						log.causa = exception.cause;				
						
						return log;
						
						]]></scripting:script>
			</scripting:transformer>
			<all>
				<component>
					<spring-object bean="mongoInsertLogComponent" />
				</component>
				<vm:outbound-endpoint path="vm.error.transmision" />
			</all>
		</catch-exception-strategy>

		<catch-exception-strategy doc:name="Catch Exception Strategy">
			<scripting:transformer doc:name="Groovy">
				<scripting:script engine="Groovy"><![CDATA[
				    	import java.text.SimpleDateFormat;
		                import java.util.Date;
		                import java.text.DateFormat;
		                import java.util.Calendar;
		                import com.pdvsa.psp.model.xml.MongoLogger;
		                
						//org.mule.api.routing.filter.FilterUnacceptedException
						 DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		                String dateStr = dateFormat.format(Calendar.getInstance().getTime());
		                
		                Date currentTime = dateFormat.parse(dateStr);
		                
		                def log = new MongoLogger();
		                log.tipoEvento = MongoLogger.Evento.DESCONOCIDO;	
						log.descripcion = "Ha Ocurrido un error desconocido en el Bus";
						log.fecha = currentTime;
						log.causa = exception.cause;				
						
						return log;
						]]></scripting:script>
			</scripting:transformer>
			<component>
				<spring-object bean="mongoInsertLogComponent" />
			</component>
			<mule-xml:object-to-xml-transformer
				doc:name="Object to XML">
				<mule-xml:alias name="response"
					class="com.pdvsa.psp.model.xml.MongoLogger" />
			</mule-xml:object-to-xml-transformer>
		</catch-exception-strategy>
	</choice-exception-strategy>

	<!-- Para Borrar la Data No Transmitida Almacenada en Mongo -->
	<flow name="DeleteHistoricRegistryLocalidad">
		<quartz:inbound-endpoint jobName="poll-delete-historic-localidad-service"
			cronExpression="0 5 8 ? * 1" repeatCount="-1" connector-ref="Quartz-Connector"
			doc:name="Quartz">
			<quartz:event-generator-job />
		</quartz:inbound-endpoint>
		<logger level="INFO"
			message="Se Borraran todo los registros de la ColecciÃ³n Historicos" />
		<component>
			<spring-object bean="mongoDeleteValidationDataComponent" />
		</component>
	</flow>

	<flow name="ConsultarBitacoraBus" doc:name="ConsultarBitacoraBus">
		<http:inbound-endpoint exchange-pattern="request-response"
			host="${rest.host}" port="${rest.port}" path="${rest.pathBase}/query-errors"
			doc:name="HTTP" />
		<jersey:resources doc:name="REST">
			<component class="com.pdvsa.psp.mule.rest.QueryErrorLogDataMongo" />
		</jersey:resources>
		<object-to-string-transformer doc:name="Object to String" />

		<message-filter throwOnUnaccepted="true" doc:name="validation-filter">
			<filter ref="opc-error-request-schema-validation" />
		</message-filter>
		<mule-xml:dom-to-xml-transformer />
		<mule-xml:xml-to-object-transformer
			returnClass="com.pdvsa.psp.model.xml.OpcErrorMongoRequest" encoding="UTF-8"
			mimeType="text/xml" doc:name="XML to Object">
			<mule-xml:alias name="OpcErrorRequest"
				class="com.pdvsa.psp.model.xml.OpcErrorMongoRequest" />
			<mule-xml:converter class="com.pdvsa.psp.converter.DateConverterMapper" />
		</mule-xml:xml-to-object-transformer>
		<component>
			<spring-object bean="mongoFindErrorComponent" />
		</component>
		<mule-xml:object-to-xml-transformer
			encoding="UTF-8" mimeType="text/xml" doc:name="Object to XML">
			<mule-xml:alias name="OpcErrorResponse"
				class="com.pdvsa.psp.model.xml.OpcErrorResponse" />
			<mule-xml:alias name="log"
				class="com.pdvsa.psp.model.xml.MongoLogger" />
		</mule-xml:object-to-xml-transformer>


		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<flow name="ExposeOpcInfoRegionService" doc:name="ExposeOpcServiceRegion">
		<http:inbound-endpoint exchange-pattern="request-response"
			host="${rest.host}" port="${rest.port}" path="${rest.pathBase}/opc-info"
			doc:name="http-save-opc-endpoint" />
		<jersey:resources doc:name="REST">
			<component class="com.pdvsa.psp.mule.rest.OpcInfoRestService" />
		</jersey:resources>
		<object-to-string-transformer doc:name="Object to String" />
		<logger level="INFO" message="#[payload]" />
		<!-- <message-filter throwOnUnaccepted="true" doc:name="validation-filter"> 
			<filter ref="opc-request-schema-validation" /> </message-filter> -->
		<mule-xml:dom-to-xml-transformer />
		<mule-xml:xml-to-object-transformer
			returnClass="com.pdvsa.psp.model.xml.OpcItemsTransfer" encoding="UTF-8"
			mimeType="text/xml">
			<mule-xml:alias name="opcItemsTransfer"
				class="com.pdvsa.psp.model.xml.OpcItemsTransfer" />
			<mule-xml:alias name="opc"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterMongo" />
			<mule-xml:converter class="com.pdvsa.psp.converter.DateConverterMapper" />
		</mule-xml:xml-to-object-transformer>

		<all>
			<component>
				<spring-object bean="mongoInsertComponent" />
			</component>
			<component>
				<spring-object bean="storeTankOpcDataCache" />
			</component>
			<component>
				<spring-object bean="mongoSaveHistoricItemsComponent" />
			</component>

		</all>
		<scripting:transformer doc:name="Groovy">
			<scripting:script engine="Groovy">
				<![CDATA[
         			import java.text.SimpleDateFormat;
         			import java.util.Date;
         			import java.text.DateFormat;
         			import java.util.Calendar;
         			import com.pdvsa.psp.model.xml.MongoLogger;
                  
      	 			//org.mule.api.routing.filter.FilterUnacceptedException
       				DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        			String dateStr = dateFormat.format(Calendar.getInstance().getTime());
                  
					Date currentTime = dateFormat.parse(dateStr);
                  
	        		def log = new MongoLogger();
        			log.tipoEvento = MongoLogger.Evento.EXITO; 
      				log.descripcion = "Se ha completado la transaccion de manera Exitosa";
      				log.fecha = currentTime;    
      
      				return log;
      			]]>
			</scripting:script>
		</scripting:transformer>
		<mule-xml:object-to-xml-transformer
			encoding="UTF-8" mimeType="text/xml" doc:name="Object to XML">
			<mule-xml:alias name="response"
				class="com.pdvsa.psp.model.xml.MongoLogger" />
		</mule-xml:object-to-xml-transformer>
		<logger level="INFO" message="RETORNANDO RESPUESTA A LOCALIDAD" />

		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<flow name="ItemsFromCacheFlow">
		<http:inbound-endpoint exchange-pattern="request-response"
			host="${rest.host}" port="${rest.port}" path="${rest.pathBase}/cache"
			doc:name="HTTP" method="GET" />
		<jersey:resources doc:name="REST">
			<component>
				<spring-object bean="itemsFromCache" />
			</component>
		</jersey:resources>
	</flow>

	<flow name="OpcDataSendToPais" doc:name="OpcDataSendToPais">
	    <quartz:inbound-endpoint jobName="poll-data-sender-mongo-region-to-pais-service" repeatInterval="20000" repeatCount="-1" connector-ref="Quartz-Connector" doc:name="Quartz">
			<quartz:event-generator-job />
		</quartz:inbound-endpoint>		
	
		<component>
			<spring-object bean="mongoFindComponentTransfer" />
		</component>
		<expression-filter expression="payload.opcItems.size() > 0"
			evaluator="groovy" />
		<set-variable variableName="originalPayload" value="#[payload.opcItems.size()]" />
		<mule-xml:object-to-xml-transformer
			encoding="UTF-8" mimeType="text/xml">
			<mule-xml:alias name="opcItemsTransfer"
				class="com.pdvsa.psp.model.xml.OpcItemsTransfer" />
			<mule-xml:alias name="opc"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterMongo" />
			<mule-xml:converter class="com.pdvsa.psp.converter.DateConverterMapper" />
		</mule-xml:object-to-xml-transformer>
		<set-variable variableName="xmlPayload" value="#[payload]" />
		<logger level="INFO" message="#[payload]" />
		<http:outbound-endpoint exchange-pattern="request-response"
			host="${rest.pais.host}" port="${rest.pais.port}"
			path="${rest.pais.pathBase}/opc-info/transfer-opc-item" method="POST" 
			doc:name="HTTP-ED" />
		<object-to-string-transformer doc:name="Object to String" />
		<mule-xml:xml-to-object-transformer
			returnClass="com.pdvsa.psp.model.xml.MongoLogger" encoding="UTF-8"
			mimeType="text/xml">
			<mule-xml:alias name="response"
				class="com.pdvsa.psp.model.xml.MongoLogger" />
		</mule-xml:xml-to-object-transformer>
		<choice>
			<when
				expression="payload.tipoEvento != com.pdvsa.psp.model.xml.MongoLogger.Evento.EXITO"
				evaluator="groovy">
				<component>
					<spring-object bean="mongoInsertLogComponent" />
				</component>
			</when>
			<otherwise>
<!-- 				<all> -->
					<component>
						<spring-object bean="mongoInsertLogComponent" />
					</component>
					<set-payload value="#[flowVars['xmlPayload']]" />
					<vm:outbound-endpoint exchange-pattern="one-way"
						path="update-opc-endpoint" doc:name="VM" />
<!-- 				</all> -->
			</otherwise>
		</choice>
		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<flow name="UpdateOpcItemRegion" doc:name="UpdateOpcItemRegion"
		processingStrategy="synchronous">
		<vm:inbound-endpoint exchange-pattern="one-way"
			path="update-opc-endpoint" doc:name="vm-update-opc-endpoint" />
		<!-- <set-payload value="#[flowVars['xmlPayload']]" /> -->
		<mule-xml:xml-to-object-transformer
			returnClass="com.pdvsa.psp.model.xml.OpcItemsTransfer" encoding="UTF-8"
			mimeType="text/xml">
			<mule-xml:alias name="opcItemsTransfer"
				class="com.pdvsa.psp.model.xml.OpcItemsTransfer" />
			<mule-xml:alias name="opc"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterMongo" />
			<mule-xml:converter class="com.pdvsa.psp.converter.DateConverterMapper" />
		</mule-xml:xml-to-object-transformer>
		<all doc:name="All">
			<!-- Esto fue movido para que se almacena en historico una vez lleguen 
				los datos de las localidades -->
			<component>
				<spring-object bean="mongoInsertValidationDataComponent" />
			</component>
			<component>
				<spring-object bean="mongoRemoveItemsComponent" />
			</component>
			<logger level="INFO"
				message="Se han Actualizado la catidad de : #[payload.opcItems.size()] Items" />
			<!-- Debemos cambiar el nombre a este elemento de maxTransicionesAPais -->
			<expression-component>
				app.registry['contador'] = 5;
			</expression-component>
		</all>

		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<flow name="ConsultarDatosOpcPentahoFlow" doc:name="ConsultarDatosOpcPentahoFlow">
		<description>Flow
			que Consulta Datos Opc en registro Historicos
			guardados en mongo, se
			presenta
			en dos modalidades,filtra por fecha
			desde-hasta y tambien por stationId
		</description>
		<http:inbound-endpoint exchange-pattern="request-response"
			host="${rest.host}" port="${rest.port}" path="${rest.pathBase}/query-vars"
			doc:name="HTTP" />
		<jersey:resources doc:name="REST">
			<component class="com.pdvsa.psp.mule.rest.QueryOpcDataMongo" />
		</jersey:resources>
		<object-to-string-transformer doc:name="Object to String" />

		<message-filter throwOnUnaccepted="true" doc:name="validation-filter">
			<filter ref="opc-request-schema-validation" />
		</message-filter>
		<mule-xml:dom-to-xml-transformer />
		<mule-xml:xml-to-object-transformer
			returnClass="com.pdvsa.psp.model.xml.OpcInfoRegisterRequest"
			encoding="UTF-8" mimeType="text/xml" doc:name="XML to Object">
			<mule-xml:alias name="Opc.Request"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterRequest" />
			<mule-xml:converter class="com.pdvsa.psp.converter.DateConverterMapper" />
		</mule-xml:xml-to-object-transformer>
		<component>
			<spring-object bean="mongoFindComponent" />
		</component>
		<mule-xml:object-to-xml-transformer
			encoding="UTF-8" mimeType="text/xml" doc:name="Object to XML">
			<mule-xml:alias name="Opc.Response"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterListResponse" />
			<mule-xml:alias name="Opc.Item"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterMongo" />
		</mule-xml:object-to-xml-transformer>

		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<flow name="ConsultarDataPentahoGet">
		<http:inbound-endpoint exchange-pattern="request-response"
			host="${rest.host}" port="${rest.port}" path="${rest.pathBase}/pentaho"
			doc:name="HTTP" method="GET" />
		<jersey:resources doc:name="REST">
			<component>
				<spring-object bean="mongoFindItemsPentahoRest" />
			</component>
		</jersey:resources>
	</flow>

	<!-- Este ultimo registro debe leerse memoria, se deposita en una estructura 
		compartida en la que almacena ExposeRegionFlow -->
	<flow name="ConsultarUltimoRegistroFlow" doc:name="ConsultarUltimoRegistroFlow">
		<http:inbound-endpoint exchange-pattern="request-response"
			host="${rest.host}" port="${rest.port}" path="${rest.pathBase}/query-last"
			doc:name="HTTP" />
		<jersey:resources doc:name="REST">
			<component class="com.pdvsa.psp.mule.rest.QueryOpcDataMongo" />
		</jersey:resources>
		<object-to-string-transformer doc:name="Object to String" />

		<message-filter throwOnUnaccepted="true" doc:name="validation-filter">
			<filter ref="opc-request-schema-validation" />
		</message-filter>
		<mule-xml:dom-to-xml-transformer />
		<mule-xml:xml-to-object-transformer
			returnClass="com.pdvsa.psp.model.xml.OpcInfoRegisterRequest"
			encoding="UTF-8" mimeType="text/xml" doc:name="XML to Object">
			<mule-xml:alias name="Opc.Request"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterRequest" />
			<mule-xml:converter class="com.pdvsa.psp.converter.DateConverterMapper" />
		</mule-xml:xml-to-object-transformer>
		<component>
			<spring-object bean="mongoFindLastOpcItem" />
		</component>
		<mule-xml:object-to-xml-transformer
			encoding="UTF-8" mimeType="text/xml" doc:name="Object to XML">
			<mule-xml:alias name="Opc.Item"
				class="com.pdvsa.psp.model.xml.OpcInfoRegisterMongo" />
		</mule-xml:object-to-xml-transformer>

		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<sub-flow name="LookupEmailAddressesSubflow">
		<set-payload value="ADMIN" doc:name="ROLE NAME" />
		<http:outbound-endpoint exchange-pattern="request-response"
			address="${soap.urlBase}/rol">
			<!-- host="localhost" port="8801" method="POST" doc:name="/psp/services/rol" 
				path="psp/services/rol" -->
			<cxf:jaxws-client doc:name="getEmailAdressesByRole"
				operation="getEmailAdressesByRole" serviceClass="com.pdvsa.psp.service.IRolService" />
		</http:outbound-endpoint>
	</sub-flow>

	<!-- Por lo que veo este flujo verifica la ultima transmision que se realizo 
		a Pais, falta determinar si una localidad no ha transmitido -->
	<flow name="ValidateTimeWithoutTransmission">
		<vm:inbound-endpoint path="vm.error.transmision" />
		<set-payload
			value="#[groovy:payload = org.mule.transport.NullPayload.getInstance()]"
			doc:name="Set Payload to Null" />
		<component>
			<spring-object bean="mongoFindLastRecordInsertedComponent" />
		</component>
		<payload-type-filter expectedType="com.pdvsa.psp.model.xml.OpcInfoRegisterMongo" />
		<set-variable variableName="fechaUltimoRegistro" value="#[payload.timestamp]" />
		<!-- Guardar esto en una clase Groovy -->
		<scripting:transformer doc:name="Groovy">
			<scripting:script engine="Groovy"><![CDATA[
                import java.text.SimpleDateFormat;
                import java.util.Date;
                import java.text.DateFormat;
                import java.util.Calendar;
                import org.joda.time.Period;
                import org.joda.time.PeriodType;
                import org.joda.time.DurationFieldType;
                import org.joda.time.DateTime;
                
                DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                String dateStr = dateFormat.format(Calendar.getInstance().getTime());
                
                def calendar1 = Calendar.getInstance();
                def calendar2 = Calendar.getInstance();
                calendar1.setTime(flowVars['fechaUltimoRegistro']);
                
                Date currentTime = dateFormat.parse(dateStr);
                
                calendar2.setTime(currentTime);
                
                def dateTime1 = new DateTime(calendar1.getTime());
                
                def dateTime2 = new DateTime(calendar2.getTime());
                
                DurationFieldType[] args = [DurationFieldType.minutes()] as DurationFieldType[];
                
                def type = PeriodType.forFields(args);
                
                def difference = new Period(dateTime1, dateTime2, type).getMinutes();
                
                payload = difference;
                
				]]></scripting:script>
		</scripting:transformer>
		<logger level="INFO"
			message="Han transcurrido #[payload] minutos desde la ultima transmision valida!" />
		<choice doc:name="Choice">
			<when expression="#[payload > app.registry.contador]">
				<expression-component>
					app.registry['contador'] =
					java.lang.Integer.valueOf(app.registry['contador']) +
					java.lang.Integer.valueOf(app.registry['sumaContador']);
				</expression-component>
				<set-payload
					value="Han transcurrido #[payload] minutos desde la ultima transmisiÃ³n de DATOS Valida, por favor Consulte el Log del Sistema para mÃ¡s informaciÃ³n"
					doc:name="Set Payload" />
				<logger level="INFO" message="#[app.registry.contador]" />
				<enricher source="#[payload]" target="#[flowVars['addresses']]">
					<flow-ref name="LookupEmailAddressesSubflow" doc:name="LookupEmailAddressesSubflow" />
				</enricher>
				<smtp:outbound-endpoint to="#[flowVars['addresses']]"
					user="${smtp.username}" password="${smtp.password}" host="${smtp.host}"
					port="${smtp.port}" subject="${email.subjectPrefix} N O T I F I C A C I O N"
					responseTimeout="10000" connector-ref="emailConnector" doc:name="SMTP" />
			</when>
			<otherwise>
				<logger level="INFO" message="NO CUMPLE CONDICION" />
			</otherwise>
		</choice>
		<exception-strategy ref="Choice_Exception_Strategy"
			doc:name="Catch_Exception_Strategy_DEFAULT" />
	</flow>

	<flow name="ValidateTimeWithoutRecievingFromLocation">
		<quartz:inbound-endpoint jobName="validar-job"
			repeatInterval="6000000" responseTimeout="10000" doc:name="QuartzValidarRecepcion"
			repeatCount="-1">
			<quartz:event-generator-job />
		</quartz:inbound-endpoint>
		<enricher target="#[payload]">
			<flow-ref name="LookupLocationsSubflow" doc:name="LookupLocationsSubflow" />
		</enricher>
		<component>
			<spring-object bean="mongoFindLastTransactionLocation" />
		</component>
		<foreach>
			<set-variable variableName="localidad" value="#[payload.localidadNombre]" />
			<scripting:transformer doc:name="Groovy">
				<scripting:script engine="Groovy"><![CDATA[
	                import java.text.SimpleDateFormat;
	                import java.util.Date;
	                import java.text.DateFormat;
	                import java.util.Calendar;
	                import org.joda.time.Period;
	                import org.joda.time.PeriodType;
	                import org.joda.time.DurationFieldType;
	                import org.joda.time.DateTime;
	                
	                DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	                String dateStr = dateFormat.format(Calendar.getInstance().getTime());
	                
	                def calendar1 = Calendar.getInstance();
	                def calendar2 = Calendar.getInstance();
	                calendar1.setTime(payload.timestamp);
	                
	                Date currentTime = dateFormat.parse(dateStr);
	                
	                calendar2.setTime(currentTime);
	                
	                def dateTime1 = new DateTime(calendar1.getTime());
	                
	                def dateTime2 = new DateTime(calendar2.getTime());
	                
	                DurationFieldType[] args = [DurationFieldType.minutes()] as DurationFieldType[];
	                
	                def type = PeriodType.forFields(args);
	                
	                def difference = new Period(dateTime1, dateTime2, type).getMinutes();
	                
	                payload = difference;
	                
					]]></scripting:script>
			</scripting:transformer>
			<choice doc:name="Choice">
				<when expression="#[payload > app.registry.contador]">
					<set-payload
						value="Han transcurrido #[payload] minutos desde que se recibio la ultima transmisiÃ³n de DATOS Valida desde la localidad: #[flowVars['localidad']], por favor Consulte el Log del Sistema para mÃ¡s informaciÃ³n"
						doc:name="Set Payload" />
					<logger level="INFO" message="#[app.registry.contador]" />
					<enricher source="#[payload]" target="#[flowVars['addresses']]">
						<flow-ref name="LookupEmailAddressesSubflow" doc:name="LookupEmailAddressesSubflow" />
					</enricher>
					<smtp:outbound-endpoint to="#[flowVars['addresses']]"
						user="${smtp.username}" password="${smtp.password}" host="${smtp.host}"
						port="${smtp.port}" subject="${email.subjectPrefix} N O T I F I C A C I O N"
						responseTimeout="10000" connector-ref="emailConnector" doc:name="SMTP" />
				</when>
				<otherwise>
					<logger level="INFO" message="NO CUMPLE CONDICION" />
				</otherwise>
			</choice>
		</foreach>
	</flow>

	<sub-flow name="LookupLocationsSubflow">
		<http:outbound-endpoint exchange-pattern="request-response"
			address="${soap.urlBase}/localidad" method="POST" doc:name="/psp/services/localidad">
			<cxf:jaxws-client doc:name="getEmailAdressesByRole"
				operation="getAllLocalidades" serviceClass="com.pdvsa.psp.service.ILocalidadService" />
		</http:outbound-endpoint>
	</sub-flow>

	<!-- ******* I M P O R T A N T E ******* -->
	<!-- Falta un flujo que determine si hay localidades que no esta transmitiendo, 
		esto es una condicion de error a tomar en cuenta -->

	<!-- *************** ****************** -->



	<!-- Servicios para la Replicacion de Configuracion a Nivel de Region -->

	<!-- <flow name="ReplicationOpcConfigurationRestFlow" doc:name="ReplicationOpcConfigurationRestFlow"> 
		<http:inbound-endpoint exchange-pattern="request-response" host="localhost" 
		port="9000" doc:name="http-synchronize-vars-endpoint" encoding="UTF-8" path="replication-opc" 
		mimeType="text/xml" /> <jersey:resources doc:name="REST"> <component> <spring-object 
		bean="opcReplicationRestService" /> </component> </jersey:resources> </flow> -->

	<!-- <flow name="ItemReplicationFlow"> <quartz:inbound-endpoint jobName="opc-polling-item-job" 
		connector-ref="Quartz-Connector" repeatInterval="10000" responseTimeout="10000" 
		doc:name="QuartzPollItemOpc" repeatCount="-1"> <quartz:event-generator-job 
		/> </quartz:inbound-endpoint> <http:outbound-endpoint exchange-pattern="request-response" 
		host="localhost" port="8801" method="GET" doc:name="/psp/services/itemopc" 
		path="psp/services/itemopc" > <cxf:jaxws-client doc:name="findItemsSoap" 
		operation="findUntransferredItems" serviceClass="com.pdvsa.psp.service.IItemService" 
		/> </http:outbound-endpoint> <set-variable variableName="originalPayload" 
		value="#[payload.size()]" /> <foreach > <mule-xml:object-to-xml-transformer 
		mimeType="text/xml" encoding="UTF-8"> <mule-xml:alias name="opcItem" class="com.pdvsa.psp.model.Item"/> 
		</mule-xml:object-to-xml-transformer> <http:outbound-endpoint exchange-pattern="request-response" 
		contentType="text/xml" host="${rest.pais.host}" port="${rest.pais.port}" 
		path="${rest.item.path}" method="POST" doc:name="HTTP-ED" /> <object-to-string-transformer 
		doc:name="Object to String" /> <vm:outbound-endpoint exchange-pattern="one-way" 
		path="update-item-endpoint" doc:name="VM" /> </foreach> <exception-strategy 
		ref="Catch_Exception_Strategy_DEFAULT" doc:name="Catch_Exception_Strategy_DEFAULT"/> 
		</flow> <flow name="updateItemReplication"> <vm:inbound-endpoint exchange-pattern="one-way" 
		path="update-item-endpoint" doc:name="vm-update-item-endpoint" /> <mule-xml:xml-to-object-transformer 
		returnClass="com.pdvsa.psp.model.Item"> <mule-xml:alias name="opcItem" class="com.pdvsa.psp.model.Item"/> 
		</mule-xml:xml-to-object-transformer> <set-payload value="#[payload.id]" 
		doc:name="id item" /> <all> <http:outbound-endpoint exchange-pattern="request-response" 
		host="localhost" port="8801" method="POST" doc:name="/psp/services/itemopc" 
		path="psp/services/itemopc" > <cxf:jaxws-client doc:name="updateItemStatus" 
		operation="updateItemStatus" serviceClass="com.pdvsa.psp.service.IItemService" 
		/> </http:outbound-endpoint> <vm:outbound-endpoint path="vm.activate.groupreplication" 
		/> </all> </flow> <flow name="GroupReplicationFlow"> <vm:inbound-endpoint 
		path="vm.activate.groupreplication"/> <set-payload value="#[groovy:payload 
		= org.mule.transport.NullPayload.getInstance()]" doc:name="Set Payload to 
		Null"/> <http:outbound-endpoint exchange-pattern="request-response" host="localhost" 
		port="8801" method="GET" doc:name="/psp/services/grupo" path="psp/services/grupo" 
		> <cxf:jaxws-client doc:name="findGroupsSoap" operation="findUntransferredGroups" 
		serviceClass="com.pdvsa.psp.service.IGrupoService" /> </http:outbound-endpoint> 
		<set-variable variableName="originalPayload" value="#[payload.size()]" /> 
		<foreach > <enricher source="#[payload]" target="#[flowVars['groupItems']]"> 
		<flow-ref name="lookupItemsPerGroup" doc:name="lookupItemsPerGroup" /> </enricher> 
		<scripting:transformer doc:name="Groovy"> <scripting:script engine="Groovy"> 
		<![CDATA[ import com.pdvsa.psp.model.xml.GrupoTransferencia; import com.pdvsa.psp.model.Item; 
		import com.pdvsa.psp.model.GrupoItem; itemsOpc = flowVars['groupItems']; 
		grupoItems = new ArrayList(); for (Item item : itemsOpc) { grupoItem = new 
		GrupoItem(); grupoItem.item = item; grupoItems.add(grupoItem); } def grupoTransferencia 
		= new GrupoTransferencia(payload, grupoItems); return grupoTransferencia; 
		]]> </scripting:script> </scripting:transformer> <mule-xml:object-to-xml-transformer 
		mimeType="text/xml" encoding="UTF-8"> <mule-xml:alias name="grupoOpcTransfer" 
		class="com.pdvsa.psp.model.xml.GrupoTransferencia"/> <mule-xml:alias name="grupo" 
		class="com.pdvsa.psp.model.Grupo"/> <mule-xml:alias name="grupoItem" class="com.pdvsa.psp.model.GrupoItem"/> 
		</mule-xml:object-to-xml-transformer> <http:outbound-endpoint exchange-pattern="request-response" 
		contentType="text/xml" host="${rest.pais.host}" port="${rest.pais.port}" 
		path="${rest.group.path}" method="POST" doc:name="HTTP-ED" /> <object-to-string-transformer 
		doc:name="Object to String" /> <vm:outbound-endpoint exchange-pattern="one-way" 
		path="update-group-endpoint" doc:name="vm-update-group-endpoint"/> </foreach> 
		<exception-strategy ref="Catch_Exception_Strategy_DEFAULT" doc:name="Catch_Exception_Strategy_DEFAULT"/> 
		</flow> <flow name="updateGroupReplication"> <vm:inbound-endpoint exchange-pattern="one-way" 
		path="update-group-endpoint" doc:name="vm-update-group-endpoint" /> <mule-xml:xml-to-object-transformer 
		returnClass="com.pdvsa.psp.model.xml.GrupoTransferencia"> <mule-xml:alias 
		name="grupoOpcTransfer" class="com.pdvsa.psp.model.xml.GrupoTransferencia"/> 
		<mule-xml:alias name="grupo" class="com.pdvsa.psp.model.Grupo"/> <mule-xml:alias 
		name="grupoItem" class="com.pdvsa.psp.model.GrupoItem"/> </mule-xml:xml-to-object-transformer> 
		<set-payload value="#[payload.id]" doc:name="id grupo"/> <all> <http:outbound-endpoint 
		exchange-pattern="request-response" host="localhost" port="8801" method="POST" 
		doc:name="/psp/services/tanque" path="psp/services/tanque" > <cxf:jaxws-client 
		doc:name="updateTanqueStatus" operation="updateTanqueStatus" serviceClass="com.pdvsa.psp.service.ITanqueService" 
		/> </http:outbound-endpoint> <vm:outbound-endpoint path="vm.activate.replicaserver"/> 
		</all> </flow> <flow name="ServidorOpcReplicationFlow"> <vm:inbound-endpoint 
		path="vm.activate.replicaserver"/> <set-payload value="#[groovy:payload = 
		org.mule.transport.NullPayload.getInstance()]" doc:name="Set Payload to Null"/> 
		<http:outbound-endpoint exchange-pattern="request-response" host="localhost" 
		port="8801" method="GET" doc:name="/psp/services/servidoropc" path="psp/services/servidoropc" 
		> <cxf:jaxws-client doc:name="findUntransferredServers" operation="findUntransferredServers" 
		serviceClass="com.pdvsa.psp.service.IServidorService" /> </http:outbound-endpoint> 
		<set-variable variableName="originalPayload" value="#[payload.size()]" /> 
		<foreach > <enricher source="#[payload]" target="#[flowVars['tanques']]"> 
		<flow-ref name="lookupTanksServer" doc:name="lookupTanksServer" /> </enricher> 
		<enricher source="#[payload]" target="#[flowVars['servidorGrupos']]"> <flow-ref 
		name="lookupServerGroups" doc:name="lookupServerGroups" /> </enricher> <scripting:transformer 
		doc:name="Groovy"> <scripting:script engine="Groovy"> <![CDATA[ import com.pdvsa.psp.model.xml.ServidorTransferencia; 
		import com.pdvsa.psp.model.ServidorGrupo; import com.pdvsa.psp.model.Tanque; 
		tanquesOpc = flowVars['tanques']; servidorGrupos = flowVars['servidorGrupos']; 
		def servidorTransferencia = new ServidorTransferencia(); if(tanquesOpc.size() 
		> 0){ servidorTransferencia.getTanques().addAll(tanquesOpc); } if(servidorGrupos.size() 
		> 0){ servidorTransferencia.getServidorGrupos().addAll(servidorGrupos); } 
		return servidorTransferencia; ]]> </scripting:script> </scripting:transformer> 
		<mule-xml:object-to-xml-transformer mimeType="text/xml" encoding="UTF-8"> 
		<mule-xml:alias name="servidorTransferencia" class="com.pdvsa.psp.model.xml.ServidorTransferencia"/> 
		<mule-xml:alias name="tanque" class="com.pdvsa.psp.model.Tanque"/> <mule-xml:alias 
		name="localidad" class="com.pdvsa.psp.model.Localidad"/> <mule-xml:alias 
		name="servidorGrupo" class="com.pdvsa.psp.model.ServidorGrupo"/> <mule-xml:alias 
		name="grupo" class="com.pdvsa.psp.model.Grupo"/> </mule-xml:object-to-xml-transformer> 
		<http:outbound-endpoint exchange-pattern="request-response" contentType="text/xml" 
		host="${rest.pais.host}" port="${rest.pais.port}" path="${rest.server.path}" 
		method="POST" doc:name="HTTP-ED" /> <object-to-string-transformer doc:name="Object 
		to String" /> <vm:outbound-endpoint exchange-pattern="one-way" path="update-servidor-endpoint" 
		doc:name="vm-update-servidor-endpoint"/> </foreach> <exception-strategy ref="Catch_Exception_Strategy_DEFAULT" 
		doc:name="Catch_Exception_Strategy_DEFAULT"/> </flow> <flow name="updateServidorReplication"> 
		<vm:inbound-endpoint exchange-pattern="one-way" path="update-servidor-endpoint" 
		doc:name="vm-update-servidor-endpoint" /> <mule-xml:xml-to-object-transformer 
		mimeType="text/xml" encoding="UTF-8"> <mule-xml:alias name="servidorTransferencia" 
		class="com.pdvsa.psp.model.xml.ServidorTransferencia"/> <mule-xml:alias name="tanque" 
		class="com.pdvsa.psp.model.Tanque"/> <mule-xml:alias name="localidad" class="com.pdvsa.psp.model.Localidad"/> 
		<mule-xml:alias name="servidorGrupo" class="com.pdvsa.psp.model.ServidorGrupo"/> 
		<mule-xml:alias name="grupo" class="com.pdvsa.psp.model.Grupo"/> </mule-xml:xml-to-object-transformer> 
		<set-payload value="#[payload.id]" doc:name="id servidor"/> <http:outbound-endpoint 
		exchange-pattern="request-response" host="localhost" port="8801" method="POST" 
		doc:name="/psp/services/servidoropc" path="psp/services/servidoropc" > <cxf:jaxws-client 
		doc:name="updateServidorStatus" operation="updateServidorStatus" serviceClass="com.pdvsa.psp.service.IServidorService" 
		/> </http:outbound-endpoint> </flow> -->

	<!-- <sub-flow name="lookupServerGroups"> <set-payload value="#[payload.id]" 
		doc:name="id servidor"/> <http:outbound-endpoint exchange-pattern="request-response" 
		host="localhost" port="8801" method="POST" doc:name="/psp/services/servidoropc" 
		path="psp/services/servidoropc" > <cxf:jaxws-client doc:name="getServidorGrupoByServidor" 
		operation="getServidorGrupoByServidor" serviceClass="com.pdvsa.psp.service.IServidorService" 
		/> </http:outbound-endpoint> </sub-flow> <sub-flow name="lookupTanksServer"> 
		<set-payload value="#[payload.id]" doc:name="id servidor"/> <http:outbound-endpoint 
		exchange-pattern="request-response" host="localhost" port="8801" method="POST" 
		doc:name="/psp/services/tanque" path="psp/services/tanque" > <cxf:jaxws-client 
		doc:name="getTanquesByServidor" operation="getTanquesByServidor" serviceClass="com.pdvsa.psp.service.ITanqueService" 
		/> </http:outbound-endpoint> </sub-flow> <sub-flow name="lookupItemsPerGroup"> 
		<set-payload value="#[payload.id]" doc:name="id grupo" /> <http:outbound-endpoint 
		exchange-pattern="request-response" host="localhost" port="8801" method="POST" 
		doc:name="/psp/services/itemopc" path="psp/services/itemopc" > <cxf:jaxws-client 
		doc:name="getItemsByGrupo" operation="getItemsByGrupo" serviceClass="com.pdvsa.psp.service.IItemService" 
		/> </http:outbound-endpoint> </sub-flow> -->

</mule>
